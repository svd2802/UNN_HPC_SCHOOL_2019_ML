# Практика 1. Инструменты разработки ПО, базовые функции Python, библиотека OpenCV

## Цели

__Цель данной работы__ - освоить инструменты разработки программного обеспечения,
перечисленные ниже, на примере решения задачи обработки изображений посредством
фильтрации или пикселизации отдельной области.

  - Система контроля версий [Git](https://git-scm.com/book/en/v2).
  - Базовый функционал языка Python.
  - Библиотека [OpenCV](opencv).

## Структура исходного кода

  1. В папке `src` расположен файл `imagefilter.py`, содержащий 
  объявление класса `ImageFilter`. Необходимо реализовать метод обработки изображения 
  `process_image`.
  1. В папке `samples` расположен файл `practice1_template.py`, в котором 
  представлена функция `main` - точка входа в программу, использующую фильтр.
  
## Задачи

__Основные задачи:__

  1. Создать на GitHub копию рабочего репозитория, содержащего практические задания школы,
     в собственном аккаунте.
  1. Создать локальную копию (на рабочей машине) репозитория, содержащего 
     практические задания школы.
  1. Настроить локальную копию репозитория для последующей синхронизации с сервером.
  1. Создать виртуальную среду и установить необходимые необходимые библиотеки.
  1. Разработать приложение для открытия исходного изображения из файла и 
     сохранения результирующего изображения в файл.
  1. Разработать фильтр для перевода изображения в оттенки серого.
  1. Разработать фильтр для изменения размера изображения.
  1. Разработать фильтр для вырезания квадрата из центральной части изображения.
  1. Сделать "commit" (зафиксировать) разработанные методы в локальном репозитории.
  1. Отправить "pull request" в основной репозиторий, содержащий шаблоны 
     практических заданий школы.

__Дополнительные задачи:__
  1. Разработать фильтр пикселизации для выделенной области изображения.
  1. Разработать приложение для открытия изображение/видео/видеопотока с 
     веб-камеры и вывода данных на экран.

## Общая последовательность действий

  1. Сделать форк upstream-репозитория.
  1. Клонировать origin-репозиторий к себе на локальную машину (раздел
     [Общие инструкции по работе с Git][git-intro]).
  1. Создать в Anaconda новую виртуальную среду Python.
  1. Установить библиотеку OpenCV в вритуальную среду Python.
  1. Запустить проект и проверить его работоспособность.
  1. Создать рабочую ветку (раздел [Общие инструкции по работе с Git][git-intro]).
  1. Реализовать отображение картинки на экране при помощи OpenCV.
     По мере готовности не забывайте выкладывать изменения в рабочую ветку на сервер.
  1. Реализовать фильтр, который переводит изображение в оттенки серого.
  1. Реализовать фильтр, который изменяет размер изображения.
  1. Реализовать фильтр, который вырезает центральную часть изображения.
  1. Сделать Pull Request в upstream-репозиторий.
  1. Решить задачи списка [Дополнительные задачи][tasks].
  
## Детальная инструкция по выполнению работы

  1. Сделать форк upstream-репозитория.
  
     1. Открыть в браузере upstream-репозиторий
        https://github.com/itlab-vision/UNN_HPC_SCHOOL_2019_ML.
     1. В правом верхнем углу нажать кнопку Fork.
     1. Выбрать в качестве организации, куда направить форк, организацию,
        соответствующую вашему аккаунту `@github-account`.

  1. Клонировать origin-репозиторий к себе на локальную машину (раздел
     [Общие инструкции по работе с Git][git-intro]).
     
     1. Открыть командную строку Git Bash (или Git Shell в зависимости от того,
        какой git-клиент установлен на вашей машине). Для этого необходимо найти
        соответствующий ярлык на рабочем столе или в меню "Пуск".
     1. Воспользоваться перечнем инструкций, описанных в разделе
        [Общие инструкции по работе с Git][git-intro]).		
 
        ```bash
        $ cd C:\
        $ git clone https://github.com/<@github-account>/UNN_HPC_SCHOOL_2019_ML.git
        ``` 
            
   1. Удостовериться, что семпл работает - запустить командную строку, в ней 
      запустить скрипт с вашим приложением.

      ```bash
      $ cd UNN_HPC_SCHOOL_2019_ML/samples
      $ python practice1_template.py
      ```
	 
  1. Создать рабочую ветку (раздел [Общие инструкции по работе с Git][git-intro]).
  
  1. Создать копию файла `<project_source>/samples/practice1_template.py` 
     и назвать ее `<project_source>/samples/practice1_YOUR_NAME.py`.
  
  1. В файле `practice1_YOUR_NAME.py` добавить чтение параметров командной 
     строки при помощи библиотеки `argparse`. В семпле уже добавлен код, который 
     создает обработчик для чтения параметров командной строки, вам нужно 
     реализовать добавление новых параметров .
  
  1. Открыть консоль Anaconda (Anaconda Prompt) и создать новую виртуальную среду.
  
     ```bash
     $ conda create -n openvino
     $ conda activate openvino
     ```
            
  1. В открытой консоли Anaconda установить библиотеку OpenCV.
  
     ```bash
     $ conda install opencv
     ```
  
  1. В файле `practice1_YOUR_NAME.py` реализовать чтение файла изображения при 
     помощи имени файла, полученного из аргументов командной строки, и вывести это 
     изображение на экран.  [Шпаргалка по OpenCV в Python][opencv-python-guide].
  
  1. В файле `imagefilter.py` написать реализацию метода `process_image`. 

      1. Для перевода изображения в оттенки серого используйте функцию 
	 [`cvtColor`][cvtcolor].
      1. Для изменения размера изображения используйте функцию 
	 [`cvResize`][cvresize].
      1. Для обрезки изображения вычислите центр изображения и максимальную 
         сторону квадрата, которую можно получить из начального изображения, 
         а затем сделайте срез изображения подобно тому, как делаются срезы 
         массивов в [`numpy`][numpy-slice-list].
  
  1. Прислать Pull Request с внесенными изменениями. Пометить в конце названия 
  `(NOT READY)`. По мере готовности решений основных задач Pull Request можно 
  будет переименовать.
  
  1. Решить задачи списка [Дополнительные задачи][tasks].
  
        1. Реализовать выделение области для пикселизации с использованием мыши
	   и разработать фильтр пикселизации. Для выделения области необходимо 
	   назначить обработчик события на окно, содержащее отображаемое изображение.
	   Для пикселизации необходимо область разделить по вертикали и горизонтали
	   на равные части и в каждой прямоугольной подобласти выполнить размытие.
        1. Разработать приложение для открытия изображения/видео/видеопотока с 
           веб-камеры и вывода данных на экран.

  
## Общие инструкции по работе с Git

В данном разделе описана типичная последовательность действий, которую
необходимо выполнить перед тем, как начать работать с проектом. Далее
для определенности используется репозиторий `CV-SUMMER-CAMP`.

  1. Создать аккаунт на [github.com](https://github.com), если такой
     отсутствует. Для определенности обозначим аккаунт `github-account`.

  1. Сделать fork репозитория
     <https://github.com/itlab-vision/UNN_HPC_SCHOOL_2019_ML> (в
     терминологии Git upstream-репозиторий) к себе в личный профиль с названием
     `github-account`. В результате будет создана копия репозитория 
     <https://github.com/github-account/UNN_HPC_SCHOOL_2019_ML>
     (origin-репозиторий).

  1. Клонировать [origin][origin] репозиторий к себе на локальный компьютер,
     воспользовавшись следующей командой:

     ```bash
     $ git clone https://github.com/   <github-account>   /UNN_HPC_SCHOOL_2019_ML
     ```

  1. Перейти в директорию `UNN-HPC-SCHOOL-2019-OPENVINO`:

     ```bash
     $ cd ./UNN_HPC_SCHOOL_2019_ML
     ```

  1. Настроить адрес upstream-репозитория (потребуется при обновлении локальной
     версии репозитория):

     ```bash
     $ git remote add upstream https://github.com/itlab-vision/UNN_HPC_SCHOOL_2019_ML
     ```

  1. Настроить имя пользователя и e-mail, из под которого будут выполняться
     все операции с репозиторием Git:

     ```bash
     $ git config --local user.name "github-account"
     $ git config --local user.email "github-email"
     ```

     Примечание: если не выполнить указанную операцию при попытке
     размещения изменений на сервер, они попадут под аккаунтом пользователя
     компьютера.
  
  1. Настроить редактор, который будет использован, если вносятся изменения
     в историю репозитория (в частности, при слиянии веток).
  
     ```bash
     $ git config --local core.editor "'C:/Program Files (x86)/Notepad++/notepad++.exe' -n -w"
     ```
        
        Когда сделан форк репозитория у вас создается по умолчанию единственная ветка
        master. Тем не менее, при решении независимых задач следует создавать рабочие
        ветки. Далее показаны основные команды для управления ветками на примере ветки
        `practice-1`.

  1. Получить список веток:

        ```bash
        $ git branch [-v]
        # [-v] - список с информацией о последних коммитах
        ```

  1. Создать ветку:

        ```bash
        $ git branch practice-1
        ```

  1. Создать ветку `practice-1` и перейти в нее:

        ```bash
        $ git checkout [-b] practice-1
        # [-b] - создание и переход в ветку <branch_name>
        ```
  1. Удалить ветку в локальном репозитории:

        ```bash
        $ git branch -d <branch_name>
        ```

  1. Удалить ветку на сервере:

        ```bash
        $ git push [remotename] :[branch]
        # [remotename] - имя удалённого репозитория. Если следовать приведённой
        #     инструкции, то origin - репозиторий пользователя github-account, upstream -
        #     репозиторий itlab-vision/UNN_HPC_SCHOOL_2019_ML
        ```

При работе с файлами в ветке необходимо управлять изменениями. Далее приведен
перечень основных команд в предположении, что текущей рабочей веткой
        является `practice-1`.

  1. Получить список текущих изменений:

        ```bash
        $ git status
        ```

  1. Пометить файл как добавленный в текущую ветку репозитория (файл будет
     добавлен после выполнения команды `commit`):

        ```bash
        $ git add [<file_name>]
        # <file_name> - название файла для добавления в commit
        #     если вместо имени указан символ *, то будут добавлены все новые файлы,
        #     не совпадающие с масками, указанными в .gitignore
        ```

  1. Добавить изменения в текущую ветку локального репозитория:

        ```bash
        $ git commit [-m "<message_to_commit>"] [-a]
        # [-a] - автоматически добавляет изменения для существующих на сервере файлов
        #     без выполнения команды git add
        # [--amend] - перезаписывает последний коммит (используется, если не забыты
        #     изменения)
        ```

  1. Разместить изменения, которые были добавлены в локальный репозиторий
     с помощью команды `commit`:

        ```bash
        $ git push [-u] origin [practice-1]
        # [-u] - отслеживать версию ветки [practice-1] на удалённом сервере
        #     (origin). Позволяет получать изменения с сервера при помощи команды git pull
        #     без явного указания имени удалённого репозитория и имени ветки.
        ```

  1. Получить изменения с сервера при помощи команды `pull` и слить их с
     отслеживаемыми ветками:

        ```bash
        $ git pull [remotename [<branch name>]]
        ```

  1. Удалить файлы или директории (!без опции `-f` для файлов, состояния
     которых совпадают с состояниям на сервере):

        ```bash
        $ git rm [-f] [--cached]
        # [-f] - принудительное удаление (файла с измененным состоянием)
        # [--cached] - удаление файлов на сервере, но не в локальной директории
        ```

  1. Переименовать файлы (или 3 команды: `mv`, `git rm`, `git add`):

        ```bash
        $ git mv <file_from> <file_to>
        ```

Когда в проекте работает несколько человек, то вполне естественная ситуация -
необходимость слияния изменений и разрешение конфликтов.

  1. Слияние (вариант 1):

        ```bash
        $ git merge upstream/master # слияние изменений из ветки upstream в master
        $ git merge master # слияние изменений из ветки master в текущую ветку
        ```

  1. Слияние (вариант 2):

        ```bash
        $ git checkout <branch_name> # переход в ветку <branch_name> (при необходимости)
        $ git rebase <base_branch> [<branch_name>] # слияние изменений из ветки <base_branch> в ветку <branch_name>
        $ git checkout <base_branch>
        $ git merge <branch_name>
        ```

  1. Инструмент для разрешения конфликтов:

        ```bash
        $ git mergetool
        ```


## Добавление аргументов командной строки в приложение

В файле `practice1_template.py` представлен шаблон функции `build_argparse`,
которая используется для разбора аргрументов командной строки. В эту функцию
необходимо дописать собственные аргументы, такие как путь до изображения,
новые размеры изображения и т.д. Параметры описываются следующим образом:  

```python
    def build_argparse(): 
        parser = argparse.ArgumentParser()
            
        parser.add_argument('-a1', '--argument1', help = 'your cmd \
            argument', type = str)

```

где `-a1` - короткое имя аргумента, `--argument1` - полное имя аргумента, `type` - тип аргумента (`int`, `float`, `str` и т.д.).

Дополнительные опции:

- `required = True` (или `False`) определяет является ли параметр обязательным.
- `default = 'defaultvalue'` - значение параметра по умолчанию.
- `nargs = 2` позволяет передать два значения через пробел.

Чтение параметров в основной программе происходит по их полному имени:

```python
    args = build_argparse().parse_args()
    variable = args.argument1             
```

<!-- LINKS -->
[opencv]: https://opencv.org
[origin]: https://github.com/itlab-vision/CV-SUMMER-CAMP
[cvtcolor]: https://docs.opencv.org/3.4.2/d7/d1b/group__imgproc__misc.html#ga397ae87e1288a81d2363b61574eb8cab
[cvresize]: https://docs.opencv.org/3.4.2/df/d4e/group__imgproc__c.html#ga1119b1dc4f6db2a393057992ed574e25
[git-intro]: https://github.com/FenixFly/CV-SUMMER-CAMP/blob/dev/docs/README_1.md#%D0%BE%D0%B1%D1%89%D0%B8%D0%B5-%D0%B8%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%86%D0%B8%D0%B8-%D0%BF%D0%BE-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B5-%D1%81-git
[numpy-slice-list]:https://pythonworld.ru/numpy/2.html
[opencv-python-guide]:https://tproger.ru/translations/opencv-python-guide/
[tasks]: https://github.com/FenixFly/CV-SUMMER-CAMP/blob/dev/docs/README_1.md#%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B8
